### V8如何执行JavaScript

### V8引擎垃圾内存回收原理
- V8内存限制
  - Java/Go对于内存的使用并没有什么限制，但是JS不一样，V8只能使用系统的一部分内存，64位下V8最多分配1.4G内存，32位下V8最多分配0.7G内存。对于前端已经够用了但是对于nodejs如果读取一个大于1.4G的文件就无法完全读入内存进行操作了。
  - 对于栈内存的垃圾回收：当ESP指针下移，也就是上下文就切换之后，栈顶的空间会自动被回收。
  - 对于堆内存来说：当我们构造一个对象进行赋值操作的时候，其实相应的内存已经分配到了堆上。你可不断的创建对象，让V8为它分配内存，直到堆的大小达到上限。
- V8为什么要设置内存上限？
  - 一个是因为JS是单线程的，一旦开始垃圾回收操作那么所有的JS逻辑都要暂停。
  - 另一个原因是因为垃圾回收是非常耗时的
  - 假设V8不做任何限制垃圾积累了非常多那么JS的执行也会越来越慢
- V8内存分类
  - V8把内存分为新生代(临时分配的内存空间，存活时间短)，老生代(常驻内存的，存活时间长)。二者相加就是V8的堆内存之和。
  - 根据不同类型的堆内存V8采用了不同的回收策略
    - 新生代的内存限制在64位和32位下分别是32MB和16MB
    - V8将新生代的内存一分为二。From/To
    - From表示正在使用的内存，To是目前闲置的内存。
    - 当进行垃圾回收时，V8将From内的对象检查一遍，如果是存活对象那么复制到To内存中(在To内存中按照顺序从头放置)，如果是非存活的直接回收。当所有的From中的存活对象按照顺序进入到To内存之后，From和To两者的角色对调，From为正在使用，To现在被闲置，如此循环下去。
    - 为什么不直接把From里垃圾直接回收掉？还要再复制一次？堆是按顺序排列的From垃圾回收以后会出现垃圾碎片，这样可能稍微大一点的对象就没办法分配内存空间了。所以按照顺序从头放置在To里面(这样就方便了后续连续空间的分配)就解决了内存碎片的问题新生代垃圾回收算法也叫做Scavenge算法 
    - Scavenge算法缺点是只能使用新生代内存的一半，优点速度快
  - 老生代内存的回收
    - 新生代中的对象经过多次回收以后依然存在的话就会被放入老生代内存这种现象叫做晋升
    - 什么情况下内=新生代中的对象会晋升到老生代中？
      - 经历过一次Scavenge垃圾回收
      - To闲置空间的内存不足75%
    - 老生代内存中积累的变量空间一般都很大，不能用Scavenge算法回收
    - 老生代采用标记清除来回收垃圾
      - 第一步：遍历堆中的所有对象对它们做上标记，然后对于代码环境中使用的变量以及被强引用的标记的变量取消标记，把剩下已经标记的进行空间的回收
      - 这样做又会出现内存碎片的问题，存活对象的空间不连续对后续的空间分配造成影响
      - 第二步：整理内存碎片。在清除阶段结束后，把存活的对象全部往一端靠拢。
      - 由于是移动对象速度会很慢，也是垃圾回收中最耗时的一部分。
        - V8对这部分又是如何优化的？
        - 由于JS是单线程机制，V8在进行垃圾回收的时候，不可避免地会阻塞业务逻辑的执行，加入老生代的垃圾回收任务很大耗时会非常严重会严重影响业务逻辑的执行。不要怕!V8对这里采取了增量标记的方案。即将一次标记完的任务分成很多小的部分完成，每做完一部分就停下来去执行一段JS业务逻辑，然后再标记下面的老生代如此循环往复，直到标记阶段结束最后清除非存活的对象整理内存碎片。
        - 经过增量标记来解决老生代对象标记以后。垃圾回收过程对JS逻辑的阻塞时间减少到原来的六分之一。