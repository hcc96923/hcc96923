
### 浏览器渲染页面的过程
- 1 用户输入关键词，地址栏判断是搜索内容还是url地址。
  - 如果是搜索内容，会使用浏览器默认搜索引擎加上搜索内容合成url；
  - 如果是域名会加上协议（如https）合成完整的url。
- 2 然后按下回车。浏览器进程通过IPC（进程间通信）把url传给网络进程（网络进程接收到url才发起真正的网络请求）。
- 3 网络进程接收到url后，先查找有没有缓存
  - 有缓存，直接返回缓存的资源。
  - 没有缓存。（进入真正的网络请求）。首先获取域名的IP，系统会首先自动从hosts文件中寻找域名对应的 IP 地址，一旦找到，和服务器建立TCP连接；如果没有找到，则系统会将网址提交 DNS 域名解析服务器进行 IP 地址的解析。
- 4 利用IP地址和服务器建立TCP连接（3次握手）。
- 5 建立连接后，浏览器构建数据包（包含请求行，请求头，请求正文，并把该域名相关Cookie等数据附加到请求头），然后向服务器发送请求消息。
- 6 务器接收到消息后根据请求信息构建响应数据（包括响应行，响应头，响应正文），然后发送回网络进程。
- 7 网络进程接收到响应数据后进行解析。
  - 如果发现响应行的返回的状态码为301，302，说明服务器要我们去找别人要数据，找谁呢？找响应头中的Location字段要，Location的内容是需要重定向的地址url。获取到这个url一切重新来过。如果返回的状态码为200，说明服务器返回了数据。
- 8 好了，获取到数据以什么方式打开呢？打开的方式不对的话也不行。打开的方式就是 Content-Type。这个属性告诉浏览器服务器返回的数据是什么类型的。如果返回的是网页类型则为 text/html，如果是下载文件类型则为 application/octet-stream 等等。打开的方式不对，则得到的结果也不对。如果是下载类型，则该请求会被提交给浏览器的下载管理器，同时该请求的流程到此结束。如果是网页类型，那么浏览器就要准备渲染页面了。
- 9 渲染页面开始。浏览器进程发出“提交文档”（文档是响应体数据）消息给渲染进程，渲染进程接收到消息后会和网络进程建立传输数据的通道，网络进程将“文档”传输给渲染进程。
- 10 一旦开始传输，渲染进程便开始渲染界面（详细渲染过程待续。。。）
- 11 传输完毕，渲染进程会发出“确认提交”消息给浏览器进程。
- 12 浏览器在接收到“确认提交”消息后，更新浏览器界面状态（包括地址栏信息，仟前进后退历史，web页面和网站安全状态）。
- 13 面此时可能还没有渲染完毕，而一旦渲染完毕，渲染进程会发送一个消息给浏览器进程，浏览器接收到这个消息后会停止标签图标的加载动画。自此，一个完整的页面形成了。
- 从耗时的角度，主要花在下面五件事上面
  - 1 DNS查询
  - 2 TCP连接
  - 3 HTTP请求
  - 4 服务器响应
  - 5 客户端渲染
### HTTP
- 网络协议就是信息在网络中传递的一些规范。如同人与人之间相互交流是需要遵循一定的规矩一样，计算机之间的湘火炬通信需要共同遵守一定的规则，这些规则就成为网络协议。
- 没有网络协议的网络世界是混乱的，计算机之间想发什么就发什么。
- 互联网中的通信协议都对应7层中的某一层![七层协议](./664199e3217c41aabad4ae057d600c73_tplv-k3u1fbpfcp-zoom-1.png)
### 强缓存与协商缓存
- 1 浏览器进行资源请求时，会判断response headers是命中强缓存，如果命中，直接从本地读取缓存，不会向服务器发送请求。
- 2 当强缓存没有命中，会发送请求到服务端，判断协商缓存是否命中，如果命中，服务器将请求返回，不会返回资源，告诉浏览器从本地读取缓存。如果不命中，服务器直接返回资源。
- 区别：强缓存命中，不会请求服务器，直接使用缓存；协商缓存命中，会请求服务器，不会返回内容，然后读取缓存。强缓存的弊端很明显，即每次都是根据时间来判断缓存是否过期；但是当到达过期时间后，如果文件没有改动，再去获取文件就有点浪费服务器的资源。这时候就需要使用协商缓存了。
- 3 缓存的处理流程
  - 3.1 from memory cache：直接从内存中拿资源，速度快，页面关闭该资源被释放。
  - 3.2 from disk cache：从硬盘中拿资源，速度慢，不会随页面关闭而释放掉。
- 4 强缓存又分为Expires(HTTP1.0)和Cache-Control(HTTP1.1)
  - 4.1 Expires是一个GMT时间格式字符串，浏览器进行第一次请求的时候，服务器会在响应头上加上强缓存又分为Expires，下次请求，如果在这个时间之前则命中缓存。不推荐使用这个，时区的原因会导致客户端的时间可能与服务器的时间不一致。
  - 4.2 Cache-Control有多个属性(max-age：缓存时长(s)，public: 浏览器和代理服务器都可以缓存，private：只有浏览器可以缓存，no-cache: 不使用强缓存尝试协商缓存，no-store：不进行缓存，s-maxage：代理服务器缓存时长，must-revalidate：告诉浏览器、缓存服务器，本地副本过期前，可以使用本地副本；本地副本一旦过期，必须去源服务器进行有效性校验。)
  - 4.3 Pragma是HTTP1.0中为了向后兼容Cache-Control的一个字段作用和ache-Control一样
  - 4.4 以上三个响应头，优先级顺序为：Pragma>Cache-Control>Expires
- 5 协商缓存分为Last-Modified(If-Modified-Since)和ETag(If-None-Match)。 
  - 5.1 Last-Modified: 响应头中的字段表示资源最后的更新时间。请求头中的字段：If-Modified-Since带上响应头中Last-Modified的值。通过比较两次的时间判断，资源在请求期间是否有修改，没有则返回304从缓存读取。否则返回新的Last-Modified时间和服务器资源。
  - 5.2 Last-Modified存在一些缺点：感知时间是秒（如果在一秒内进行了多次修改）。被修改的一些内容是注释。ETag为响应头的字段，表示资源的唯一标识，随服务器返回。服务器比较请求头中的If-None-Match和当前资源的ETag是否一致来决定是否返回资源还是使用缓存。
  - 5.3 从精确度上来说ETag比Last-Modified更准确，相应的所占的内容页更大一些。
### OPTIONS请求
  - 1 CORS(Cross-Origin-Resource-Sharing)跨域资源共享是针对跨域的一种解决方案。分为简单请求和非简单请求。针对非简单请求，浏览器首先使用OPTIONS方法发起一个预检请求(preflight request)，从而获知服务端是否允许该跨域请求。服务器确认之后，才发起实际的HTTP请求。在预检请求的返回中，服务器端也可以通知客户端，是否需要携带身份凭证
    - 1.1 只要是满足下图的都是简单请求不需要发起预检请求。
    - Access-Control-Max-Age这个响应头表示预检请求的返回结果可以被缓存多久。
### V8引擎垃圾内存回收原理
- V8内存限制
  - Java/Go对于内存的使用并没有什么限制，但是JS不一样，V8只能使用系统的一部分内存，64位下V8最多分配1.4G内存，32位下V8最多分配0.7G内存。对于前端已经够用了但是对于nodejs如果读取一个大于1.4G的文件就无法完全读入内存进行操作了。
  - 对于栈内存的垃圾回收：当ESP指针下移，也就是上下文就切换之后，栈顶的空间会自动被回收。
  - 对于堆内存来说：当我们构造一个对象进行赋值操作的时候，其实相应的内存已经分配到了堆上。你可不断的创建对象，让V8为它分配内存，直到堆的大小达到上限。
- V8为什么要设置内存上限？
  - 一个是因为JS是单线程的，一旦开始垃圾回收操作那么所有的JS逻辑都要暂停。
  - 另一个原因是因为垃圾回收是非常耗时的
  - 假设V8不做任何限制垃圾积累了非常多那么JS的执行也会越来越慢
- V8内存分类
  - V8把内存分为新生代(临时分配的内存空间，存活时间短)，老生代(常驻内存的，存活时间长)。二者相加就是V8的堆内存之和。
  - 根据不同类型的堆内存V8采用了不同的回收策略
    - 新生代的内存限制在64位和32位下分别是32MB和16MB
    - V8将新生代的内存一分为二。From/To
    - From表示正在使用的内存，To是目前闲置的内存。
    - 当进行垃圾回收时，V8将From内的对象检查一遍，如果是存活对象那么复制到To内存中(在To内存中按照顺序从头放置)，如果是非存活的直接回收。当所有的From中的存活对象按照顺序进入到To内存之后，From和To两者的角色对调，From为正在使用，To现在被闲置，如此循环下去。
    - 为什么不直接把From里垃圾直接回收掉？还要再复制一次？堆是按顺序排列的From垃圾回收以后会出现垃圾碎片，这样可能稍微大一点的对象就没办法分配内存空间了。所以按照顺序从头放置在To里面(这样就方便了后续连续空间的分配)就解决了内存碎片的问题新生代垃圾回收算法也叫做Scavenge算法 
    - Scavenge算法缺点是只能使用新生代内存的一半，优点速度快
  - 老生代内存的回收
    - 新生代中的对象经过多次回收以后依然存在的话就会被放入老生代内存这种现象叫做晋升
    - 什么情况下内=新生代中的对象会晋升到老生代中？
      - 经历过一次Scavenge垃圾回收
      - To闲置空间的内存不足75%
    - 老生代内存中积累的变量空间一般都很大，不能用Scavenge算法回收
    - 老生代采用标记清除来回收垃圾
      - 第一步：遍历堆中的所有对象对它们做上标记，然后对于代码环境中使用的变量以及被强引用的标记的变量取消标记，把剩下已经标记的进行空间的回收
      - 这样做又会出现内存碎片的问题，存活对象的空间不连续对后续的空间分配造成影响
      - 第二步：整理内存碎片。在清除阶段结束后，把存活的对象全部往一端靠拢。
      - 由于是移动对象速度会很慢，也是垃圾回收中最耗时的一部分。
        - V8对这部分又是如何优化的？
        - 由于JS是单线程机制，V8在进行垃圾回收的时候，不可避免地会阻塞业务逻辑的执行，加入老生代的垃圾回收任务很大耗时会非常严重会严重影响业务逻辑的执行。不要怕!V8对这里采取了增量标记的方案。即将一次标记完的任务分成很多小的部分完成，每做完一部分就停下来去执行一段JS业务逻辑，然后再标记下面的老生代如此循环往复，直到标记阶段结束最后清除非存活的对象整理内存碎片。
        - 经过增量标记来解决老生代对象标记以后。垃圾回收过程对JS逻辑的阻塞时间减少到原来的六分之一。