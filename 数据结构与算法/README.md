### 数据结构与算法
- 1.学习数据结构与算法为了大厂的面试
- 2.理解第三方库框架的原理，这些基础框架一般都是用数据结构与算法
- 3.写出更高效的代码更快更省的代码
### 高效学习数据结构与算法
- 1.数据结构就是指一组数据的存储结构组织方式，算法就是操作数据的一组方法
- 2.数据结构就是指数据在内存中摆放的方式，而算法就是操作这些数据的方法
- 3.数据结构是为算法服务的，算法要作用在特定的数据结构之上才能更高效的运行
- 4.学习它的来历，自身的特点，适合解决的问题以及实际的应用场景
- 5.学知识的过程是反复迭代，不断沉淀的过程
- 6.每周周末把本周学习的数据结构与算法的题练习一遍
### 最常用的数据结构与算法
- 10个数据结构：数组，链表，队列，二叉树，栈，堆，散列表，图，跳表，Trie树
- 10个算法：递归，排序，二分查找，搜索，哈希算法，分治算法，贪心算法，回溯算法，动态规划，字符串匹配算法
### 时间复杂度
- 1.大O时间复杂度表示**代码执行时间随数据规模增长的变化趋势**也叫渐进时间复杂度。T(n) = O(2n+2)
- 2.当n很大时那些常量就可以忽略，因为它们不足以影响变化趋势或者对变化趋势的影响很小。T(n) = O(n)
- 3.计算时间复杂度的三个方法：
  - 3.1只关注循环次数最多的一段代码
    - 我们通常会忽略掉公式中的常量、低阶、系数，只需要记录一个最大阶的量级就可以了
    - 我们在分析一个算法、一段代码的时间复杂度的时候，也只关注循环执行次数最多的那一段代码就可以了
  - 3.2总复杂度等于量级最大的那段代码的复杂度
    - 比如一个复杂度为O(n2+n+10000) => O(n2)，这里的n和10000都对增长趋势没有影响
  - 3.3嵌套代码的复杂度等于嵌套内外代码复杂度的乘积
  - 一个函数有1000行赋值语句它的复杂度也是O(1)因为代码总的执行时间并没有因为数据量的改变而改变
- 时间复杂度：表示算法的执行时间与数据规模之间的增长关系。
  - 常见的复杂度有：O(1)，O(logn)等比数列，O(n)，O(nlogn)，O(n2)，O(n3)，O(2n)，O(!n)
- 空间复杂度：表示算法的存储空间与数据规模之间的增长关系。
  - 常见的复杂度有：O(1)，O(n)，O(n2)
- 只要代码的执行时间不随n的增大而增长这样代码的时间复杂度都为O(1)
- 最好情况时间复杂度。
- 最坏情况时间复杂度。
- 平均情况时间复杂度。
- 均摊时间复杂度。
### 空间复杂度
- 1.表示算法的存储空格键与数据规模之间的增长关系也叫渐进空间复杂度
- 2.空间复杂度指的是除了原本的数据存储空间外，算法运行还需要额外的存储空间
### 数组
- 数组是一种线性表数据结构。它用一组连续的内存空间，常见的线性数据结构还有链表，队列，栈。
- 线性表的特点是数据之间是简单的前后关系/相反非线性表二叉树，堆，图就不是简单的前后关系
- 数组存储的数据在内存中的地址是连续的，这也是其支持快速随机访问的原因。
- `a[i]_address = base_address + i * data_type_size`。根据首地址，要查找的元素的索引，元素的内存大小就可以计算出要查找的元素的地址。
- 数组查找的时间复杂度为O(1)。插入和删除的时间复杂度为O(n)。
- 插入或删除第k个元素则为了保持数组中的元素在内存中的连续性，所以需要移动k-n个元素的位置，这就是数组插入和删除低效率的原因。因为我们在每个位置插入的概率一样所以平均情况时间复杂度为(1+2+3+...+n)/n = O(n)
### 链表
- 链表分为单项链表，循环链表，双向链表。
- 单向链表：头节点记录了链表的基地址，有了它就可以遍历整个链表，尾节点的指针指向null表示这是链表的最后一个节点。
  - 在链表中进行插入与删除的操作是非常快速的。O(1)（实际上这种说法并不准确，删除或者插入也需要知道要操作的节点的前置节点还是需要遍历，只不过插入/删除这一行操作的时间复杂度是O(1)）。当然没有完美的数据结构，链表的查找相较于数组就比不上了。因为它需要遍历所有的节点去找出要查找的节点。可以把链表当作一个队伍，队伍中的每人都知道自己后面是谁，所以当我们要找出第k位的人是谁的时候，就需要从第一个人开始，一个一个地往下数。O(n)
- 循环链表：是一种特殊的单向链表。循环链表的尾节点的指针指向链表的头节点。
- 双向链表有两个指针prev和next分别指向了前置节点和后直节点这样无论是查找还是插入和删除相比单项链表效率都要提高很多（空间换时间）
### 栈
- LIFO先进后出操作受限制的线性数据结构
- 栈是如何实现浏览器的前进后退？
- 两个栈A和B
- 首次浏览的页面压入栈A，后退的时候再依次从A中出栈压入栈B
- 再点击前进的时候再从栈B弹出
### 队列
- FIFO先进先出操作受限制的线性数据结构一端入队列另一端出队列
- 队列可以把它想象成排队吃饭，后来的人只能在后面不能插队，先来的可以先买饭
### 递归
- 递归需要满足的三个条件
- 1.一个问题的解可以分解为几个子问题的解
- 2.这个问题与分解之后的子问题除了数据规模不同，求解思路完全一样
- 3.**存在递归终止的条件**
- 4.写出递推公式找出终止条件
- 编写递归代码的关键是，只要遇到递归，我们就把它抽象成一个地推公式，不用想一层层的调用关系
- 不要试图用人脑去分解递归的每个步骤
### 排序
- 