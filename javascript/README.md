### 数组
- array.splice(index, length, arg) 返回含有被截取的这个值的一个新数组，原数组被改变，第三个参数替换之前的元素
- array.slice(start, end)返回含有被截取元素的数组，不改变原数组
- array.slice()返回数组array的一份拷贝，与原数组在栈中的内存地址不一样
- **数组元素可以看作是数组对象的属性**。JavaScript中以0开头的属性不能用.引用必须用[]获取
- forEach没有返回值强制return也是undefined
- every和some默认返回false
- filter默认返回空数组，否则返回符合条件的元素
- find默认返回undefined，否则返回第一个符合条件的那个元素
- findIndex默认返回-1，否则返回第一个符合条件元素的下标
- map默认返回数组元素为undefined，否则返回一个新的数组不改变原数组
- reduce默认返回undefined
- reduce(callback(accumulator, currentValue, index, array), initialValue)

### call
- 改变this的指向
- 传入参数
- 执行函数
### apply
- 改变this的指向
- 传入参数数组
- 执行函数
### bind
- 改变this的指向
- 返回一个函数
- 可以传入参数
- 柯里化：只传递给函数一部分参数来调用它，让它返回一个函数去调用剩下的参数。
```
    var add = function(x) {
        return function(y) {
            return x + y;
        }
    }
    var increment = add(1);
    var addTen = add(10);

    increment(2);
    // 3

    addTen(2);
    // 12

    add(1)(2);
    // 3
```

### 深浅拷贝原理
- 什么是浅拷贝，这个对象有着原始对象属性值的一份精确拷贝。如果属性是基本类型，拷贝的就是这个基本类型的值，如果属性是引用类型，拷贝的就是内存地址，所以如果其中一个对象改变了这个地址，就会影响到另一个对象。
- 简单的来说浅拷贝解决了第一层的问题，拷贝第一层的基本类型值，以及第一层的引用类型地址。
- 浅拷贝的两份对象不相等，有着不同的内存地址
- 浅拷贝的实现方式有Object.assign()，{...}，slice()
- 深拷贝内存开销大。拷贝前后两个对象互不影响。
- 深拷贝实现方式有JSON.parse(JSON.stringfy())。但是会忽略undefined，symbol，function。循环引用会报错。new Date()转换结果不正确（转换成字符串或者时间戳就行了）。不能正确处理正则
- 浅拷贝就是拷贝第一层的基本类型值，以及第一层引用类型地址
- in遍历对象时，in操作符会检查属性是否在对象及其原型上
- hasOwnProperty只会检查属性是否在当前对象上，不会检查原型链
- typeof 基本类型返回其数据类型
- typeof 引用类型返回不同
  - typeof null // object
  - typeof {} // object
  - typeof [] // object
  - typeof function foo(){} // function


### Object.prototype是浏览器根据ECMAScript规范创造的一个对象
- Object.prototype就是原型链的顶端（不考虑null的情况下）,所有对象继承了toString等方法和属性。


### 高阶函数
- 接受一个或多个函数作为输入/输出一个函数。
- 高阶函数就是一个接收函数作为参数传递或者将函数作为返回值输出的函数。
- JavaScript内置了一些高阶函数forEach，map，some，every，filter
- JavaScript打印函数时会自动调用toString方法


### EventLoop
- 进程是程序运行的一次过程(CPU分配内存的基本单位)
- 线程共享进程所有资源是执行一段指令的过程(CPU调度和分派的基本单位)
- 以Chrome浏览器为例，主要的进程有四个
  - 浏览器进程（Browser Process）：负责浏览器的TAB的前进，后退，地址栏，书签栏的工作和处理浏览器一些不可见的底层操作，比如网络请求文件的访问
  - 渲染进程（Render Process）：负责一个Tab内的显示相关工作，也称渲染引擎
  - 插件进程（Plugin Process）：负责控制网页使用到的插件
  - GPU进程（GPU Process）：负责处理整个应用程序的GPU任务
  - JavaScript引擎线程是工作在渲染进程下的
- JS单线程的好处
  - JS运行的时候可能会阻止UI渲染。JS是可以修改DOM结构的，如果在UI渲染线程工作的时候，就可能导致不能安全的渲染UI
  - 可以节约内存。可以节约上下文切换的时间。异步解决了JS的阻塞。
- JS代码执行分为同步和异步
  - 同步：变量的声明，for循环，赋值操作
  - 异步：setTimeout，setInterval，I/O，UI操作，Promise
    - 异步代码会被加到任务队列中，任务队列分为两种
    - 宏任务队列可以有多个script(同步代码)，setTimeout，setInterval，I/O
    - 微任务只有一个队列异步：setTimeout，setInterval，Promise
    - 微任务快于宏任务是建立在异步的前提下
- JS是单线程的，所有的同步任务都会放在主线程中执行。主线程之外，还有一个任务队列。每当一个异步任务有了结果就会往任务队列里塞一个事件。当主线程中的任务，都执行完成以后，JS引擎会依次读取任务队列里的事件。然后进入主线程开始执行
- JS的单线程就是主线程同步代码在主线程上执行完成以后，执行栈会把异步代码调到主线程执行

### V8引擎垃圾内存回收原理
- V8内存限制
  - Java/Go对于内存的使用并没有什么限制，但是JS不一样，V8只能使用系统的一部分内存，64位下V8最多分配1.4G内存，32位下V8最多分配0.7G内存。对于前端已经够用了但是对于nodejs如果读取一个大于1.4G的文件就无法完全读入内存进行操作了。
  - 对于栈内存的垃圾回收：当ESP指针下移，也就是上下文就切换之后，栈顶的空间会自动被回收。
  - 对于堆内存来说：当我们构造一个对象进行赋值操作的时候，其实相应的内存已经分配到了堆上。你可不断的创建对象，让V8为它分配内存，直到堆的大小达到上限。
- V8为什么要设置内存上限？
  - 一个是因为JS是单线程的，一旦开始垃圾回收操作那么所有的JS逻辑都要暂停。
  - 另一个原因是因为垃圾回收是非常耗时的
  - 假设V8不做任何限制垃圾积累了非常多那么JS的执行也会越来越慢
- V8内存分类
  - V8把内存分为新生代(临时分配的内存空间，存活时间短)，老生代(常驻内存的，存活时间长)。二者相加就是V8的堆内存之和。
  - 根据不同类型的堆内存V8采用了不同的回收策略
    - 新生代的内存限制在64位和32位下分别是32MB和16MB
    - V8将新生代的内存一分为二。From/To
    - From表示正在使用的内存，To是目前闲置的内存。
    - 当进行垃圾回收时，V8将From内的对象检查一遍，如果是存活对象那么复制到To内存中(在To内存中按照顺序从头放置)，如果是非存活的直接回收。当所有的From中的存活对象按照顺序进入到To内存之后，From和To两者的角色对调，From现在被闲置，To为正在使用，如此循环下去。
    - 为什么不直接把From里垃圾直接回收掉？还要再复制一次？堆是按顺序排列的From垃圾回收以后会出现垃圾碎片，这样可能稍微大一点的对象就没办法分配内存空间了。所以按照顺序从头放置在To里面(这样就方便了后续连续空间的分配)就解决了内存碎片的问题新生代垃圾回收算法也叫做Scavenge算法 
    - Scavenge算法缺点是只能使用新生代内存的一半，优点速度快
  - 老生代内存的回收
    - 新生代中的对象经过多次回收以后依然存在的话就会被放入老生代内存这种现象叫做晋升
    - 什么情况下内=新生代中的对象会晋升到老生代中？
      - 经历过一次Scavenge垃圾回收
      - To闲置空间的内存占用超过25%
    - 老生代内存中积累的变量空间一般都很大，不能用Scavenge算法回收
    - 老生代采用标记清除来回收垃圾
      - 第一步：遍历堆中的所有对象对它们做上标记，然后对于代码环境中使用的变量以及被强引用的标记的变量取消标记，把剩下已经标记的进行空间的回收
      - 这样做又会出现内存碎片的问题，存活对象的空间不连续对后续的空间分配造成影响
      - 第二步：整理内存碎片。在清除阶段结束后，把存活的对象全部往一端靠拢。
      - 由于是移动对象速度会很慢，也是垃圾回收中最耗时的一部分。
        - V8对这部分又是如何优化的？
        - 由于JS是单线程机制，V8在进行垃圾回收的时候，不可避免地会阻塞业务逻辑的执行，加入老生代的垃圾回收任务很大耗时会非常严重会严重影响业务逻辑的执行。不要怕!V8对这里采取了增量标记的方案。即将一次标记完的任务分成很多小的部分完成，每做完一部分就停下来去执行一段JS业务逻辑，然后再标记下面的老生代如此循环往复，直到标记阶段结束最后清除非存活的对象整理内存碎片。
        - 经过增量标记来解决老生代对象标记以后。垃圾回收过程对JS逻辑的阻塞时间减少到原来的六分之一。