### 数组
- array.splice(index, length, arg) 返回含有被截取的这个值的一个新数组，原数组被改变，第三个参数替换之前的元素
- array.slice(start, end)返回含有被截取元素的数组，不改变原数组
- array.slice()返回数组array的一份拷贝，与原数组在栈中的内存地址不一样
- **数组元素可以看作是数组对象的属性**。JavaScript中以0开头的属性不能用.引用必须用[]获取
- forEach没有返回值强制return也是undefined
- every和some默认返回false
- filter默认返回空数组，否则返回符合条件的元素
- find默认返回undefined，否则返回第一个符合条件的那个元素
- findIndex默认返回-1，否则返回第一个符合条件元素的下标
- map默认返回数组元素为undefined，否则返回一个新的数组不改变原数组
- reduce默认返回undefined
- reduce(callback(accumulator, currentValue, index, array), initialValue)
### call
- 改变this的指向
- 传入参数
- 执行函数
### apply
- 改变this的指向
- 传入参数数组
- 执行函数
### bind
- 改变this的指向
- 返回一个函数
- 可以传入参数
- 柯里化：只传递给函数一部分参数来调用它，让它返回一个函数去调用剩下的参数。
```
    var add = function(x) {
        return function(y) {
            return x + y;
        }
    }
    var increment = add(1);
    var addTen = add(10);

    increment(2);
    // 3

    addTen(2);
    // 12

    add(1)(2);
    // 3
```
### 深浅拷贝原理
- 什么是浅拷贝，这个对象有着原始对象属性值的一份精确拷贝。如果属性是基本类型，拷贝的就是这个基本类型的值，如果属性是引用类型，拷贝的就是内存地址，所以如果其中一个对象改变了这个地址，就会影响到另一个对象。
- 简单的来说浅拷贝解决了第一层的问题，拷贝第一层的基本类型值，以及第一层的引用类型地址。
- 浅拷贝的两份对象不相等，有着不同的内存地址
- 浅拷贝的实现方式有Object.assign()，{...}，slice()
- 深拷贝内存开销大。拷贝前后两个对象互不影响。
- 深拷贝实现方式有JSON.parse(JSON.stringfy())。但是会忽略undefined，symbol，function。循环引用会报错。new Date()转换结果不正确（转换成字符串或者时间戳就行了）。不能正确处理正则
- 浅拷贝就是拷贝第一层的基本类型值，以及第一层引用类型地址
- in遍历对象时，in操作符会检查属性是否在对象及其原型上
- hasOwnProperty只会检查属性是否在当前对象上，不会检查原型链
- typeof 基本类型返回其数据类型
- typeof 引用类型返回不同
  - typeof null // object
  - typeof {} // object
  - typeof [] // object
  - typeof function foo(){} // function
### Object.prototype是浏览器根据ECMAScript规范创造的一个对象
- Object.prototype就是原型链的顶端（不考虑null的情况下）,所有对象继承了toString等方法和属性。
### 高阶函数
- 接受一个或多个函数作为输入/输出一个函数。
- 高阶函数就是一个接收函数作为参数传递或者将函数作为返回值输出的函数。
- JavaScript内置了一些高阶函数forEach，map，some，every，filter
- JavaScript打印函数时会自动调用toString方法
### EventLoop
- 进程是程序运行的一次过程(CPU分配内存的基本单位)
- 线程共享进程所有资源是执行一段指令的过程(CPU调度和分派的基本单位)
- 以Chrome浏览器为例，主要的进程有四个
  - 浏览器进程（Browser Process）：负责浏览器的TAB的前进，后退，地址栏，书签栏的工作和处理浏览器一些不可见的底层操作，比如网络请求文件的访问
  - 渲染进程（Render Process）：负责一个Tab内的显示相关工作，也称渲染引擎
  - 插件进程（Plugin Process）：负责控制网页使用到的插件
  - GPU进程（GPU Process）：负责处理整个应用程序的GPU任务
  - JavaScript引擎线程是工作在渲染进程下的
- JS单线程的好处
  - JS运行的时候可能会阻止UI渲染。JS是可以修改DOM结构的，如果在UI渲染线程工作的时候，就可能导致不能安全的渲染UI
  - 可以节约内存。可以节约上下文切换的时间。异步解决了JS的阻塞。
- JS代码执行分为同步和异步
  - 同步：变量的声明，for循环，赋值操作
  - 异步：setTimeout，setInterval，I/O，UI操作，Promise
    - 异步代码会被加到任务队列中，任务队列分为两种
    - 宏任务队列可以有多个script(同步代码)，setTimeout，setInterval，I/O
    - 微任务只有一个队列异步：Promise.then(), catch(), finally()，ajax
    - 浏览器会先执行一个宏任务——再执行当前执行栈产生的微任务——再进行渲染，然后再执行下一个宏任务。宏任务与微任务不在一个任务队列。
    - await前面的代码相当于new Promise的同步代码，await以后的代码相当于Promise.then的异步代码
- EventLoop + GUI执行顺序
  - ![EventLoop + GUI](./Snipaste_2020-10-23_13-34-15.png)
- JS是单线程的，所有的同步任务都会放在主线程中执行。主线程之外，还有一个任务队列。每当一个异步任务有了结果就会往任务队列里塞一个事件。当主线程中的任务，都执行完成以后，JS引擎会依次读取任务队列里的事件。然后进入主线程开始执行
- JS的单线程就是主线程同步代码在主线程上执行完成以后，执行栈会把异步代码调到主线程执行
### JS运行机制
- CPU可以有很多进程，CPU在运行一个进程的时候其它进程处于非运行的状态，CPU使用**时间片轮转调度算法**来实现同时运行多个进程（为每一个进程都分配一段运行的时间200ms）
- 进程和线程的区别？
  - 进程是操作系统分配资源的最小单位，线程是程序执行的最小单位
  - 进程之间相互独立，互不影响。但同一个进程下的线程共享程序的内存空间（包括代码段，数据集，堆等）
  - 线程上下文的切换要比进程切换快的多
- 浏览器包含哪些进程？
  - 浏览器进程
    - 浏览器的主进程，只有一个。
    - 负责界面的显示，用户交互。前进后退等。
    - 负责各个页面的管理，创建和销毁其它进程。
    - 将渲染进程得到的内存中的Bitmap位图，绘制到用户界面上
    - 网络资源的管理，下载。
  - GPU进程
    - 该进程也只有一个用于3D绘制等等。
  - 插件进程
    - 每种类型的插件对应一个进程，一个插件崩溃了不会影响其它插件的使用，当使用该插件时才会创建该进程。
  - 渲染进程
    - 页面的渲染，JS的执行，事件的循环，都在渲染进程内执行。
    - 渲染进程是多线程的。也就是说某一个线程的运行会影响其它线程的执行
    - GUI渲染线程
      - 负责渲染浏览器界面，解析HTML，CSS，构建DOM树，CSSOM（规则）树，把DOM树和CSSOM树结合生成render（渲染）树
      - 当我们修改元素的颜色或者背景色，页面会发生重绘
      - 当我们修改元素的尺寸，元素的位置，display，就会发生重排
      - 重排比重绘更消耗性能因此我们要尽量避免重绘和重排
      - GUI渲染线程和JS线程是互斥的
        - 当JS引擎执行解析JS代码时，GUI线程会被挂起。
        - GUI的更新会被保存在一个队列中等到JS引擎空闲时立即执行
    - JS引擎线程负责处理JavaScript代码（例如V8引擎）
      -  一个tab页面中无论什么时候都只有一个一个JS线程在运行JS
      -  JS的解析会阻塞GUI线程（在解析HTML遇到script标签GUI的渲染会停止去解析JS。如果解析JS时间过长会造成页面的卡顿）
    - 事件触发线程
      - 负责将准备好的事件交给JS引擎线程执行
      - 属于浏览器而不是JS引擎，用来控制事件循环，并且管理者一个事件队列
      - 当js执行碰到事件绑定和一些异步操作（setTimeout,鼠标点击,ajax异步请求）会走事件触发线程将对应的事件添加到对应的线程中。定时器操作便把定时器事件添加到定时器线程，异步事件有了结果便把他们的回调操作添加到事件队列等待js引擎空闲时来处理
    - 定时器触发线程
      - setInterval与setTimeout所在线程
      - 通过单线程来计时并触发定时（计时完毕后，添加到事件触发线程队列中，等待JS空闲来执行）
      - W3C规定低于4ms的算作4ms
    - 异步http
      - 执行到一个http请求时，就把异步请求事件添加到异步请求线程，等收到响应（http状态变化），再把回调函数添加到事件队列中，等JS引擎线程来执行 
  - EventLoop
    - JS分为同步任务和异步任务。同步任务都在主线程执行（就是JS引擎线程）形成一个执行栈
    - 主线程之外还有一个事件触发线程管理着一个任务队列，只要异步任务有了结果（setTimeout/setInterval时间到0，Promise为resolve，http状态变化）。就会把这些异步任务的回调注册到任务队列中。一旦执行栈中的所有同步任务执行完毕（也就是JS引擎线程空闲了）JS引擎线程会向事件触发线程发起询问，询问事件队列中是否有需要执行的回调函数，如果有将事件队列中的回调事件加入执行栈中，开始执行回调，如果事件队列中没有回调，JS引擎线程会一直发起询问，直到有为止。将任务队列中注册的异步回调添加到执行栈中执行。
    - 定时器触发线程只关注定时不关注结果，定时结束就把回调扔给事件触发线程。
    - 异步http请求线程只关注http请求也不关心结果，http请求状态改变之后，就把回调扔给事件触发线程。
    - 事件触发线程只关心异步回调加入事件队列
    - JS引擎线程只会执行执行栈中的事件，执行栈中的代码执行完毕，就会读取事件队列中的事件并添加执行栈中继续执行，这样循环往复就是Event Loop事件轮询
### 重学ES6
- js有一个顶层对象，它提供全局环境（全局作用域），所有的代码都是在这个环境中执行的。浏览器的顶层对象时window对象，Node指的是global对象
- 暂时死区
  - 时间上暂时无法达到的区域
  - ES6标准指出：let/const声明的变量，当它们包含的词法环境被实例化时（程序的控制流程在新的作用域进行实例化时）它们会被创建（此作用域中的let/const声明的白能量会先在作用域中被创建出来，但因此时还未进行此法绑定，也就是对声明语句进行求值运算，所以是不能被访问的，访问就会抛出错误，所以在变量进入作用域它们的词法环境被实例化，但是变量还没求值，所以这段时间内不能访问），但只有在变量的词法绑定已经被求值运算后，才能够被访问。
  - 箭头函数的this来自上下文的词法环境（上层this），call，bind，apply也无法改变。箭头函数不能作为构造函数
  - Promsie解决了什么？回调地狱，第三方库的回调函数不确定回调的结果/错误的结果交给第三方库处理不信任
  - Promise是一个状态机初始状态时pending变为fulfilled或rejected。必须有Promise实例主动调用then把结果从Promise中取出来，调用catch把错误的结果取出来。这样主动权就回到了开发者手上
  - ES6 Module使用import导入模块，export导出模块
    - ES6 Module是静态的，编译阶段运行，和var和function一样具有提升效果（这个特点使得它支持tree shaking）
    - 自动采用严格模式（顶层的this返回undefined）
- 数据类型
  - Undefined
    - undefined
  - Null
    - null
  - String
  - Number
  - Boolean
    - true/false
  - Object(包含Function、Array、Date、RegExp、Error、Math)
  - Symbol
  - BigInt是一种新的数据类型，用于当整数值大于Number数据类型支持的范围时。
    - 在JS中所有的数字都以双精度64位浮点格式来表示，这导致JS中的Number无法精确表示非常大的整数，它会将非常大的整数四舍五入
    - `BigInt("9007199254740995");    // → 9007199254740995n`
- null是对象嘛？为什么？
  - null不是对象。
  - 虽然typeof null会输出object，但是这是js存在的一个悠久的bug。在JS的最初版本中使用的32位系统，为了性能考虑使用低位存储变量的类型信息，000开头代表是对象然而null表示为全零，所以将它错误的判断为object
- '1'.toString()为什么可以调用？
  - 这个语句运行的过程中做了这样几件事情：
  - `var s = new Object('1');` // 创建Object类实例由于Symbol和BigInt的出现，对它们调用new都会报错，目前ES6规范也不建议用new来创建基本类型的包装类
  - `s.toString()` // 调用实例方法
  - `s = null` // 执行完方法立即销毁这个实例
- JS中类型转换有哪几种？
  - js中类型转换只有三种：
  - 转换成数字
  - 转换成布尔值
  - 转换成字符串
  - ![JS类型转换](./16de9512eaf1158a.png)
  - ![JS==判等](./Snipaste_2020-10-23_14-34-22.png)
### DOM事件流之事件捕获以及事件冒泡
- DOM事件流
  - dom事件流分为三个阶段：
  - 1 捕获阶段
  - 2 当前目标阶段
  - 3 冒泡阶段
  - 比如我们给一个div注册了点击事件，则DOM事件流图![DOM事件流](./cc4a5d6020464ad0830d0619767f12d4_tplv-k3u1fbpfcp-zoom-1.png)
  - 1-4是捕获阶段，4是当前目标阶段，4-7是冒泡阶段
  - 在事件捕获概念下发生click事件的顺序应该是：document -> html -> body -> 目标元素
  - 事件执行都是从最顶层的元素开始的
  - 与事件捕获相反的则是事件冒泡，事件执行都是从最底层的元素开始的。
  - 一般情况下不标明事件冒泡还是事件捕获的话，默认都是按事件冒泡来处理。既有捕获又有冒泡的话先捕获再冒泡
### 前端加密算法
- 目前常见的加密算法可以分为三类
  - 对称加密算法：AES
    - 对称加密指的是加密和解密使用相同密钥的加密算法。它要求发送发和接收方在安全通信之前，商定一个密钥。对称算法的安全性依赖于密钥，泄露密钥意味着任何人都可以对他们发送的消息进行加密与解密
    - 特点：算法公开，计算量小，加密速度快
    - 缺点：密钥一旦泄露，加密信息相当于明文了
    - 使用场景：https通信，网络传输
    - AES是最常见的对称加密算法
    - ![AES](./AES.png)
    - ![AES2](./AES2.png)
  - 非对称加密算法：RSA
    - 非对称加密算法需要两个密钥：公开密钥（publickey:公钥）和私有密钥（privatekey:私钥）。公钥与私钥是一对，如果公钥对数据进行加密，只有用对应的私钥才能解密。因为加密和解密使用的是两个不同的密钥，所以也被称作非对称加密算法。
    - 特点：非对称加密与对称加密相比其安全性更好
    - 缺点：加密和解密花费时间长，速度慢，只适合少量数据进行加密
    - 使用场景：https会话前期，CA数字证书，信息加密，登录认证
    - RSA加密算法是非对称加密算法最常见的一种
    - ![RSA](./RSA.png)
    - ![RSAS](./Snipaste_2020-10-22_15-51-46.png)
  - Hash算法：MD5
    - Hash：就是把任意长度的输入通过散列算法变换成固定长度的输出，该输出就是哈希值。这种转换是一种压缩映射，散列值的空间通常远小于输入的空间，不同的输入可能会散列成相同的输出，而不能从散列值来唯一的确定输入值
    - 特点：不可逆，易计算，特征化
    - 缺点：可能存在散列冲突
    - 使用场景：文件或字符串一致性校验，数字签名，鉴权协议
    - MD5是比较常见的Hash算法(SHA1,SHA256,SHA384)
    - ![MD5](./Snipaste_2020-10-22_16-01-39.png)
  - Base64编码
    - Base64编码只是一种编码格式并不是加密算法，它可用于在HTTP环境下传递较长的标识信息。
    - 特点：可以将任意的二进制数据进行Base64编码
    - 数据加密之后，数据量会变大，变大1/3左右
    - 编码的结果末尾有个=号
    - 可以解码
    - ![Base64](./Snipaste_2020-10-22_16-05-00.png)
  - JWT算法主要分为3个部分：header(头部信息)，payload(消息体)，signature(签名) 
    - header部分指定了该JWT使用的签名算法：header = '{"alg":"HS256","type":"JWT"}'
    - payload部分声明了token的iss(签发者)，sub(所面向的用户)，exp(过期时间)和自定义的数据
    - signature部分为jwt的签名，主要为了让jwt不能随意篡改
    - ![JWT实现原理](./JWT实现原理.png)
### 面试题
- HTML5新特性
  - 语义化标签header,nav,main,article,aside,footer,section还有新增的video,audio
    - 用户体验，CSS样式丢失依然尽可能的呈现清晰的页面结构
    - SEO搜索引擎优化
    - 利于后面的开发和维护
  - canvas,webgl，svg,,websocket,本地存储,地理定位，
- CSS3新特性
  - 动画，opacity，transiton，transform，旋转，缩放，移动
  - border-radius，shadow
  ```
  transition: property duration timing-function delay;
  // css属性名称   过渡时间  过渡时间曲线  过渡延迟时间
  ```
  ```
  transform:rotate(30deg)  旋转
  transform:translate(100px,20px)  移动
  transform:scale(2,1.5);  缩放
  transform:skew(30deg,10deg);  扭曲
  ```
  ```
  animation: move 1s linear forwards;
  // 动画的名称
  // 定义动画的时间  duration 
  // 动画的贝塞尔曲线
  // animation-fill-mode 属性规定动画在播放之前或之后，其动画效果是否可见。 
  // infinate  当动画完成后，保持最后一个属性值	
  ```
- 清除浮动
  ```
    clearfix:after {
      content: "",
      display: block,
      clear: both
    }
    .clearfix {
      *zoom: 1
    }
  ```
  ```
  父级元素overflow: hidden
  ```

- event.preventDefault()   // 阻止默认事件
- event.stopPropagation() //阻止冒泡
- BFC：是一个隔离的独立的容器，容器里面的子元素不受外面元素的影响
  - 计算BFC高度时，浮动元素也参与计算
  - 创建：根元素
  - float不为none
  - position为absolute或fixed
  - overflow不为visible


  - 内部元素会在垂直方向上一个接一个的放置
  - box垂直方向的距离由margin决定，同一个BFC的两个margin会发生重叠
  - 计算BFC的高度时，浮动子元素也参与计算（即内部有浮动元素时也不会发生高度塌陷）
  - BFC的区域不会与float的元素区域重叠
  - BFC内部的元素会在垂直方向上放置

- 比如Symbol提出是为了解决什么问题？可以往全局变量冲突讲。

- 比如BigInt，解决的问题是大数问题，超过了安全数，怎么办？
- Demo.constructor.prototype
- Demo.__proto__
- Object.getPrototypeOf(Demo)

- WeakMap/WeakSet 和 Map/Set 的第一个不同点就是，WeakMap 的键必须是对象，不能是原始值。不能遍历。键名所指的对象，不计入垃圾回收机制。WeakMap 里面的键名对象和所对应的键值对会自动消失，不用手动删除引用。不会造成内存泄漏
- Object.is()使用过吗？跟 === 和 == 区别
- 两等号判等，会在比较时进行类型转换。
- 使用 Object.is 来进行相等判断时，一般情况下和三等号的判断相同，它处理了一些特殊的情况，比如 -0 和 +0 不再相等，两个 NaN 认定为是相等的。
- 反射型 XSS 攻击指的就是恶意脚本作为**「网络请求的一部分」**，随后网站又把恶意的JavaScript脚本返回给用户，当恶意 JavaScript 脚本在用户页面中被执行时，黑客就可以利用该脚本做一些恶意操作。
- 窃取Cookie
- 监听用户行为，比如输入账号密码后之间发给黑客服务器
- 在网页中生成浮窗广告
- 修改DOM伪造登入表单
### hash与history
- 前端路由实现起来其实很简单，本质就是监听 URL 的变化，然后匹配路由规则，显示相应的页面，并且无须刷新页面。目前前端使用的路由就只有两种实现方式
- 即地址栏URL中的#符号，它的特点在于：hash 虽然出现URL中，但不会被包含在HTTP请求中，对后端完全没有影响，不需要后台进行配置，因此改变hash不会重新加载页面。
- 利用了HTML5 History Interface 中新增的pushState() 和replaceState() 方法（需要特定浏览器支持）。history模式改变了路由地址，因为需要后台配置地址。
- Jsonp 就是利用script标签跨域特性进行请求。
- 当解析到link时，页面会同步加载所引的 css，而@import所引用的 css 会等到页面加载完才被加载；
- Proxy与Object.defineProperty()的对比
  - Proxy
    - 可以直接监听对象而非属性,并返回一个新对象
    - 可以直接监听数值的变化
    - 可以劫持整个对象，并返回一个新对象
  - Object.defineProperty()
    - 只能劫持对象的属性，我们需要对每个对象的每个属性进行遍历，无法监控到数组下标的变化，导致直接通过数组的下标给数组设置值，不能实时响应
- 既然vue不能检测以下标形式来操作数组属性值/长度的变动，但是提供vm.$set的API来供我们使用。
- FastClick 是 FT Labs 专门为解决移动端浏览器 300 毫秒点击延迟问题所开发的一个轻量级的库。
- Vue开启一个异步队列，并缓冲在此事件循环中发生的所有数据变化。
- Vue3.0新特性
  - 双向响应原理由Object.defineProperty改为基于ES6的Proxy，使其颗粒度更大，速度更快
  - 重写了 Vdom ，突破了 Vdom 的性能瓶颈
  - 进行了模板编译的优化
  - Tree-Shaking 的支持。修剪树叶一样把不需要的东西给修剪掉，使 Vue3 的体积更小。
  - composition-api 是一个 Vue3 中新增的功能，它的灵感来自于 React Hooks ，是比 mixin 更强大的存在。
  - Reactivity 模块独立开来，意味着 Vue3.0 的响应式模块可以与其他框架相组合。
  - 如上图，composition-api 把复杂组件的逻辑抽地更紧凑，而且可以将公共逻辑进行抽取。
  - Fragments不再限制 template 只有一个根节点。render函数也可以返回数组了，有点像 React.Fragments
  - Better TypeScript Support更好的类型推导，使得 Vue3 把 TypeScript 支持得非常好
  - 在Vue3中，定义 data，methods、watch、computed、数据 等都放在了 setup() 函数中
- nextTick dom更新是异步的过程，原因是为了提高性能避免多次修改dom，所以把多个dom操作合并成一个操作，使用nexttick则是在dom更新后的回调，此时可以获取到对应dom更新后的结果
- diff只会比较同一层级的节点
- 如果两个节点都是一样的则比较子节点，如果两个节点不一样则直接用Vnode替换oldNode。即使子节点一样
- 不同父节点的相同子节点不能复用
- 作用域链是基于执行上下文中变量环境中的outer（指向外部执行上下文）来决定的，词法作用域是基于代码中函数声明的位置来决定的，所以词法作用域是静态作用域（解决了JS没有静态作用域的问题），作用域的查找也是先根据词法作用域然后再根据变量环境，this解决了对象内的方法可以使用对象内的属性
- JavaScript用栈来保存执行上下文为JS代码的运行提供宿主环境，但是栈不存放实际的对象和函数，这些数据太大了，所以存储在堆上了
- V8内存的垃圾回收新生代老生代都是基于代际假说，大部分对象在内存中存活的时间很短，少部分对象会活的更久
- 新生代老生代的垃圾回收都是先标记活动对象和非活动对象，然后统一清理非活动对象，整理活动对象以及内存碎片问题
- 新生区分为对象区域与空闲区域使用scavenge算法进行垃圾回收，新加入的对象都被放入对象区域，当对象区域快满的时候，就执行垃圾标记清除操作，将活动的对象复制到到空闲区域，还会把对象有序的排列起来，然后，把对象区域与空闲区域进行角色反转，这样对象区域和空闲区与就可以循环的使用下去了。两次垃圾回收还存活的对象就会被移动到老生区
- 老生区的垃圾回收是基于标记清除和标记整理以及增量标记算法：具体就是标记活动对象和非活动对象，然后清除非活动对象（这里V8用了对象的可达性来判断这个对象是否还存活，遍历根元素，递归遍历可以达到的是活动的不可达到的是非活动的对象）：标记整理是清理完所有垃圾之后把所有存活对象移动到另一端。但是标记和清理的过程很耗费时间因此又出了增量标记类似于fiber算法标记一会，执行一会JS代码避免全停顿。
- 建议大家在判断一个变量是不是未定义的话，尽量使用void 0 === undefined」 很有可能undefined会被当作是变量来赋值
- 如果Symbol.toPrimitive()方法，优先调用再返回 
- 调用valueOf()，如果转换为原始类型，则返回
- 调用toString()，如果转换为原始类型，则返回
- 如果都没有返回原始类型，会报错
```
var a = {
  value: 0,
  valueOf: function() {
    this.value++;
    return this.value;
  }
};
console.log(a == 1 && a == 2);//true
```
- HTTP1.1
  - 增加了持久连接，同时6个TCP，CDN域名分片
  - 问题：6个TCP带宽竞争（比如只有一个TCP在使用）
  - 问题：TCP的慢启动：6个慢启动
  - HTTP1.1对头阻塞问题一个TCP管道只能容得下一个HTTP请求/前面的HTTP请求不响应后面的就发不出去
- HTTP2.0
  - 只维护一个TCP管道解决了带宽竞争，只需要一次慢启动，解决了HTTP的对头阻塞，多路复用
  - 多路复用的实现原理：添加了一个二进制分帧层，HTTP经过二进制分帧层被分割为一块一块带有的id的帧，到达服务器，服务器再根据id组合成完整的请求，服务器还可以根据请求的优先级来优先响应某些请求，二进制分帧层收到响应后将响应数据分割为一个一个带有ID的帧，浏览器再将带有同样id的帧合并成一个完整的响应数据
  - 设置优先级，解决了HTTP1.1对头阻塞，服务端推送，头部压缩
- HTTP3.0
  - HTTP2解决了应用层的对头阻塞但是没有解决TCP的对头阻塞问题/HTTP2中TCP如果丢包的话后面的包都会等待丢包的数据重传
  - TCP队头阻塞是由于单个数据包丢失造成的不断重传，HTTP对头阻塞是因为TCP管道只允许一个HTTP请求从而阻塞后面的HTTP请求
  - 因此HTTP多次丢包还不如HTTP1.1一个管道丢包还有5个管道可以用
  - HTTP存在一些比较严重与TCP协议相关的严重缺陷，但由于TCP协议僵化，因此很难通过修改TCP协议来改进，只能通过绕过TCP协议，但是如果采用新的协议设备支持性不好，HTTP3才用了折衷的办法基于UDP改进实现了类似HTTP的多路复用，传输可靠的QUIC协议
- XSS
  - 跨站脚本攻击的简称：黑客向用户的网页中插入恶意JS来做一些坏事
  - 监听用户的输入：账号密码
  - 获取cookie
  - 生成广告，影响用户体验
  - 基于存储的（存储到服务器用户访问被攻击），基于反射的（用户请求服务器将恶意脚本发送给服务器，服务器响应用户受到攻击），基于DOM的（路由劫持）
  - 对用户的输入过滤和转码
  - 充分利用CSP禁止加载第三方脚本，禁止向第三方发送cookie，提供了上报机制，可以帮助我们尽快发现有哪些XSS攻击，帮助我们尽快解决XSS攻击
  - httpOnly只能通过http获取cookie
- CSRF
  - 跨站请求伪造
  - 利用用户的登陆状态来做坏事、不是讲脚本插入到HTML中
  - 例如你点了第三方链接——第三方链接利用你的登陆状态向支付宝发起转账请求（前提是支付宝有CSRF漏洞）
  - 充分利用Cookie的SameSite属性
    - Strict最严格完全禁止第三方cookie
    - Lax相对宽松：第三方站点get才会携带
    - None任何情况下都会发送
  - 验证请求来源
    - Referer包含域名的完整信息list/id=96/Origin只包含域名
    - 
  - 携带CSRF Token第三方站点发起的请求不会携带
- HTTPS
  - 非对称加密用于传输对称加密的密钥
- 微任务通常来说就是需要在当前 task 执行结束后立即执行的任务 比如对一系列动作做出反馈，或者是需要异步的执行任务而又不需要分配一个新的 task，这样便可以减小一点性能的开销。
- nextTick当页面中的数据发生改变了，就会把该任务放到一个异步队列中，只有在当前任务空闲时才会进行DOM渲染，当DOM渲染完成以后，该函数就会自动执行。id重复的Watcher不会被多次加入到queue中去。这也解释了同一个watcher被多次触发，只会被推入到队列中一次。
- CommonJS与ES6模块化的区别
  - commonjs是Nodejs服务端的模块化。ES6模块化是浏览器端的模块化
  - commonjs的require是同步的（node加载一个文件都是从本地磁盘上读取同步的没关系）
  - es6是异步的因为加载的文件一般都是远程的（CDN）
  - commonJs输出的是一个值的拷贝（一旦输出了某个值，如果模块内部后续的变化影响不了外部对这个值的引用）
  - es6模块输出的值是引用
- Object 是所有对象的爸爸，所有对象都可以通过 __proto__ 找到它
- Function 是所有函数的爸爸，所有函数都可以通过 __proto__ 找到它 
- CSP 本质上就是建立白名单，开发者明确告诉浏览器哪些外部资源可以加载和执行。我们只需要配置规则，如何拦截是由浏览器自己实现的。

- 那么实现合成事件的目的是什么呢？总的来说在我看来好处有两点，分别是：

- 合成事件首先抹平了浏览器之间的兼容问题，另外这是一个跨浏览器原生事件包装器，赋予了跨浏览器开发的能力对于原生浏览事件来说，浏览器会给监听器创建一个事件对象。如果你有很多的事件监听，那么就需要分配很多的事件对象，造成高额的内存分配问题。但是对于合成事件来说，有一个事件池专门来管理它们的创建和销毁，当事件需要被使用时，就会从池子中复用对象，事件回调结束后，就会销毁事件对象上的属性，从而便于下次复用事件对象。
- setState集齐一批待更新的数据后，一次更新完，减少频繁更新带来的性能上的消耗
- 受控组件，表单元素的修改会实时映射到状态值上，此时就可以对输入的内容进行校验
- Portal 提供了一种很好的将子节点渲染到父组件以外的 DOM 节点的方式。ReactDOM.createPortal(child, container)
- 在react中使用常量用static字段
- class MyComponent extends React.Component { static DEFAULT_PAGINATION = 10 }
- vue.js的生命周期一共有10个：
- beforeCreate：实例初始化之后，this指向创建实例，不能访问到data、computed、watch、method上订单方法和数据
- created：实例创建完成，可访问data、computed、watch、method上的方法和数据，未挂载到DOM，不能访问到$el属性，$ref属性内容为空数组
- beforeMount：在挂载开始之前被调用，beforeMount之前，会找到对应的template，并编译成render函数
- mounted：实例挂载到DOM上，此时可以通过DOMAPi获取到DOM节点，$ref属性可以访问
- beforeUpdate：响应式数据更新时调用，发生在虚拟DOM打补丁之前
- updated：虚拟DOM重新渲染和打补丁之后调用，组件DOM已经更新，可执行依赖于DOM的操作
- activated：keep-alive开启时调用
- deactivated：keep-alive关闭时调用
- beforeDestroy：实例销毁之前调用。实例仍然完全可用，this仍能获取到实例
- destroy：实例销毁后调用，调用后，Vue实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁
