<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <script>
        // 三个状态：PENDING、FULFILLED、REJECTED 
        const PENDING = 'PENDING';
        const FULFILLED = 'FULFILLED';
        const REJECTED = 'REJECTED';


        class Promise {
            // new Promise时需要传递一个executor()执行器，执行器立即执行
            // promise只能从pending到rejected，或者从pending到fulfilled，状态一旦确认，就不会再改变
            constructor(executor) { 
                // 默认状态为PENDING
                this.status = PENDING;
                // 存放成功状态的值，默认为undefined
                this.value = undefined;
                // 存放失败状态的值
                this.reason = undefined;
                // 存放成功的回调
                this.onResolvedCallbacks = [];
                // 存放失败的回调
                this.onRejectedCallbacks = [];


                // 调用此方法就是成功
                let resolve = (value) => {
                    // 状态为PENDING时才可以更新状态，防止executor中调用了两次resolve/reject方法
                    if (this.status === PENDING) {
                        this.status = FULFILLED;
                        this.value = value;
                        // 一次将对应的函数执行
                        this.onResolvedCallbacks.forEach(fn => fn());
                    }
                }
                // 调用此方法就是失败
                let reject = (reason) => {
                    // 状态为PENDING时才可以更新状态，方式executor中调用了两次resolve/reject方法
                    if (this.status === PENDING) {
                        this.status = REJECTED;
                        this.reason = reason;
                        // 一次将对应的函数执行
                        this.onRejectedCallbacks.forEach(fn => fn());
                    }
                }

                try {
                    // 立即执行，将resolve和reject函数传给使用者
                    executor(resolve, reject);
                } catch (error) {
                    // 发生异常时执行失败逻辑
                    reject(error);
                }
            }

            // 包含一个then方法，并接收两个参数onFulfilled成功的回调、onRejected失败的回调
            then(onFulfilled, onRejected) {
                // 声明返回的promise2
                // resolvePromise函数，处理自己return的promise和默认的promise2的关系
                let promise2 = new Promise((resolve, reject) => {
                    // 状态为FULFILLED，执行onFulfilled并传入成功的值
                    if (this.status === FULFILLED) {
                        let x = onFulfilled(this.value);
                        resolvePromise(promise2, x, resolve, reject);
                    };
                    // 状态为REJECTED，执行onRejected并传入失败的原因
                    if (this.status === REJECTED) {
                        let x = onRejected(this.reason);
                        resolvePromise(promise2, x, resolve, reject);
                    };


                    if (this.status === PENDING) {
                        // 如果promise的状态时pending，需要将onFulfilled和onRejected函数存放起来，等待状态确定后，再依次将对应的函数执行
                        this.onResolvedCallbacks.push(() => {
                            let x = onFulfilled(this.value);
                            resolvePromise(promise2, x, resolve, reject);
                        });

                        // 如果promise的状态是pending，需要将onFulfilled和onRejected函数存放起来，等待状态确定后，再依次将对应的函数执行
                        this.onRejectedCallbacks.push(() => {
                            let x = onRejected(this.reason);
                            resolvePromise(promise2, x, resolve, reject);
                        });
                    }
                });
                // 返回promise，完成链式
                return promise2;
            }
        }
        
        const promise = new Promise((resolve, reject) => {
            // resolve('Success');

            // 当resolve再setTimeout内执行，then时status还是PENDING等待状态
            // 我们就需要在then调用的时候，将成功和失败存到各自的数组，一旦reject或resolve就调用他们
            setTimeout(() => {
                resolve('成功');
            },1000);
        }).then(data => {
            console.log('success', data);
        }, error => {
            console.log('faild', error);
        });
    </script>
</body>
</html>